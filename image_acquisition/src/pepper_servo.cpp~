#include "pepper_servo.h"

	              		                         /*
	              		                        ###
 	          		                      ## ##
	          		                      ##  ##
	          		                       ####
	          		                         :
 	          		                       #####
	          		                       ######
	          		                       ##  ##
	          		                       ##  ##
	          		                       ##  ##
	          		                       ##  ##########
 	          		                      ##  #############
	          		                  #######  ###############
	          		              #############################
	          		        .###################################
	          		       #####################################;
	          		       ##                                 ##.
	          		       ##                                 ##
	          		       #####################################
	          		       ##                                 ##
	          		       ##       The cake is a lie         ##
	          		       ##                                 ###
	          		    #####                                 #####
	          		   ### ##################################### ###
	          		  ###  ##                                 ##  ###
	          		  ##   ##                                 ##   ##
	          		  ##   ##,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,##   ##
	          		   ##  #####################################  ##
	          		    ##                                       ##
	          		     ####                                 ####
	          		       ######                         ######
          			          ##############################*/
          			          
          		
          		
          		
/***************************************************************************************************
*
*   The function display_trajectory() that allows to display the trajectory of the current features 
*   in the image. From the 3D coordinates of the points given in the object frame, we compute their 
*   respective position in the camera frame, then we apply the perspective projection before 
*   retrieving their positions in sub-pixels in the image thanks to the camera parameters. 
*   The successive sub-pixel positions are stored in a vector named traj and displayed as a 
*   green trajectory.
*
**************************************************************************************************/     		
void display_trajectory(const vpImage<unsigned char> &I, std::vector<vpPoint> &point, const vpHomogeneousMatrix &cMo, const vpCameraParameters &cam)
{
     static std::vector<vpImagePoint> traj[4];
     vpImagePoint cog;
     for (unsigned int i=0; i<4; i++) 
     {
          // Project the point at the given camera position
          point[i].project(cMo);
          vpMeterPixelConversion::convertPoint(cam, point[i].get_x(), point[i].get_y(), cog);
          traj[i].push_back(cog);
     }
     for (unsigned int i=0; i<4; i++) 
     {
          for (unsigned int j=1; j<traj[i].size(); j++) 
          {
                  vpDisplay::displayLine(I, traj[i][j-1], traj[i][j], vpColor::green);
          }
     }
}
          		
          			          
          			          
          			          
/***************************************************************************************************
 *
 *   This service can be called to test an image based visual servo control simulation.
 *   Each call to this service returns the next velocity vector.
 *
 **************************************************************************************************/	          
bool simulateVelocityVectorCalculation(pepper_servo_package::request_servo_velocity_vector::Request &req, pepper_servo_package::request_servo_velocity_vector::Response &res)
{
	// This part of the function gets locked if it is still calculating the next velocity
	// vector in the servo application. Hence, this service will return false if it is still busy. 
	ROS_INFO("Service called (simulateVelocityVectorCalculation)");
	std::string request_message = req.request_message.c_str();
	if(!program_lock)
	{
	     ROS_INFO("Program not locked, starting simulateVelocityVectorCalculation");
		program_lock = true;
          try {
               // If the servo simulation is not yet initialized, then initialize global variables.
               // The control message is compared to the incoming request message.
               //
               std::string control_message = "initialize";
               if(!simulation_initialized && request_message == control_message)
               {                    
                    ROS_INFO("Initializaing simulation");
                    // Then we define four 3D points that represent the corners of a 20cm by 20cm square. 
                    point[0].setWorldCoordinates(-0.1,-0.1, 0);
                    point[1].setWorldCoordinates( 0.1,-0.1, 0);
                    point[2].setWorldCoordinates( 0.1, 0.1, 0);
                    point[3].setWorldCoordinates(-0.1, 0.1, 0);
                    
                    // Output the coordinates as markers for RVIZ to visualize.
                    for (int i = 0 ; i < 4 ; i++) 
                    {
                       visualization_msgs::Marker marker;                  
                       marker.header.frame_id     = "/world_frame";
                       marker.header.stamp        = ros::Time::now();
                       marker.ns                  = ros::this_node::getName().c_str();
                       marker.id                  = i;
                       marker.type                = visualization_msgs::Marker::CYLINDER;
                       marker.action              = visualization_msgs::Marker::ADD;
                       marker.pose.position.x     = point[i].get_oX();
                       marker.pose.position.y     = point[i].get_oY();
                       marker.pose.position.z     = point[i].get_oZ();           
                       marker.pose.orientation.x  = 0.0;
                       marker.pose.orientation.y  = 0.0;
                       marker.pose.orientation.z  = 0.0;
                       marker.pose.orientation.w  = 1.0;
                       marker.scale.x             = 0.05;
                       marker.scale.y             = 0.05;
                       marker.scale.z             = 0.001;
                       marker.color.r             = 1.0f;
                       marker.color.g             = 0.0f;
                       marker.color.b             = 0.0f;
                       marker.color.a             = 1.0;
                       goal_marker_publisher.publish(marker);
                       // A very short sleep is required otherwise only 
                       // a part of the markers are published.
                       ros::Duration(0.001).sleep();
                    }
                    
                    
                    // The instantiation of the visual servo task is done with the next lines. 
                    // We initialize the task as an eye in hand visual servo. Resulting velocities computed 
                    // by the controller are those that should be applied in the camera frame: Vc 
                    // The interaction matrix will be computed from the current visual features. Thus they 
                    // need to be updated at each iteration of the control loop. Finally, the constant gain 
                    // lambda is set to 0.5. 
                    task.setServo(vpServo::EYEINHAND_CAMERA);
                    task.setInteractionMatrixType(vpServo::CURRENT);
                    task.setLambda(0.5);
                    
                    // It is now time to define four visual features as points in the image-plane. 
                    // To this end we instantiate the vpFeaturePoint class. The current point feature s is 
                    // implemented in p[i]. The desired point feature s* is implemented in pd[i]. 
                    // Each feature is obtained by computing the position of the 3D points in the corresponding 
                    // camera frame, and then by applying the perspective projection. Once current and desired 
                    // features are created, they are added to the visual servo task. 
                    for (unsigned int i = 0 ; i < 4 ; i++) 
                    {
                         point[i].track(cdMo);
                         vpFeatureBuilder::create(pd[i], point[i]);
                         point[i].track(cMo);
                         vpFeatureBuilder::create(p[i], point[i]);
                         task.addFeature(p[i], pd[i]);
                    }
                    
                    // Here we also specify the sampling time to 0.040 seconds. When a velocity is applied 
                    // to the camera, this time will be used by the exponential map to determine the next 
                    // position of the camera.
                    robot.setSamplingTime(0.040);
    
                    // From the initial position wMc of the camera and the position of the object 
                    // previously fixed in the camera frame cMo, we compute the position of the object in the 
                    // world frame wMo. Since in our simulation the object is static, wMo will remain unchanged.
                    robot.getPosition(wMc);
                    wMo = wMc * cMo;
                    
                    // Update simulated camera pose to starting pose. 
                    vpTranslationVector sim_cam_translation;
                    vpQuaternionVector  sim_cam_rotation;    
                    cMo.extract(sim_cam_translation);
                    cMo.extract(sim_cam_rotation);
                    
                    //ROS_INFO("Quaternion.x: %f", sim_cam_rotation.x());
                    //ROS_INFO("Quaternion.y: %f", sim_cam_rotation.y());
                    //ROS_INFO("Quaternion.z: %f", sim_cam_rotation.z());
                    //ROS_INFO("Quaternion.w: %f", sim_cam_rotation.w());
                   
                    simulated_camera_position = tf::Vector3(sim_cam_translation[0], sim_cam_translation[1], sim_cam_translation[2]);
                    simulated_camera_rotation = tf::Quaternion(sim_cam_rotation.x(), sim_cam_rotation.y(), sim_cam_rotation.z(), sim_cam_rotation.w());

                    // The servo loop will start at iteration zero.
                    iteration = 0;
                    
                    simulation_initialized = true;
               }  
               else
               {
                    // When initialized, perform servo loop.
                    std::string control_message = "cycle";
                    if(simulation_initialized && request_message == control_message)
                    {
                         // Now we can enter in the visual servo loop. When a velocity is applied to our free 
                         // flying camera, the position of the camera frame wMc will evolve wrt the world frame. 
                         // From this position we compute the position of object in the new camera frame.      
                         ROS_INFO("Simulating at iteration: %d", iteration);
                         if(iteration < 150)
                         {
                              robot.getPosition(wMc);
                              cMo = wMc.inverse() * wMo;
                              
                              // The current visual features are then updated by projecting the 3D points in the 
                              // image-plane associated to the new camera location cMo. 
                              for (unsigned int i = 0 ; i < 4 ; i++) 
                              {
                                   point[i].track(cMo);
                                   vpFeatureBuilder::create(p[i], point[i]);
                              }
                              // Finally, the velocity skew v is computed. 
                              vpColVector v = task.computeControlLaw();
                              
                              // This 6-dimension velocity vector is then applied to the camera.
                              robot.setVelocity(vpRobot::CAMERA_FRAME, v);
                              ROS_INFO("\n");
                              task.print();
                              ROS_INFO("\n");
                              
                              // Fill and send velocity vector as response to this service.
                              std::vector<double> velocity_vector(6);
                              velocity_vector[0] = v.operator[](0); 
                              velocity_vector[1] = v.operator[](1); 
                              velocity_vector[2] = v.operator[](2); 
                              velocity_vector[3] = v.operator[](3); 
                              velocity_vector[4] = v.operator[](4); 
                              velocity_vector[5] = v.operator[](5); 
                              
                              res.servo_velocity_vector = velocity_vector;
		                    ROS_INFO("Velocity vector has been sent: %f %f %f %f %f %f", velocity_vector[0], velocity_vector[1], velocity_vector[2], velocity_vector[3], velocity_vector[4], velocity_vector[5]);

                              // Update simulated camera pose to next pose. 
                              vpTranslationVector sim_cam_translation;
                              vpQuaternionVector  sim_cam_rotation;    
                              cMo.extract(sim_cam_translation);
                              cMo.extract(sim_cam_rotation);
                              
                              //ROS_INFO("Quaternion.x: %f", sim_cam_rotation.x());
                              //ROS_INFO("Quaternion.y: %f", sim_cam_rotation.y());
                              //ROS_INFO("Quaternion.z: %f", sim_cam_rotation.z());
                              //ROS_INFO("Quaternion.w: %f", sim_cam_rotation.w());
                             
                              simulated_camera_position = tf::Vector3(sim_cam_translation[0], sim_cam_translation[1], sim_cam_translation[2]);
                              simulated_camera_rotation = tf::Quaternion(sim_cam_rotation.x(), sim_cam_rotation.y(), sim_cam_rotation.z(), sim_cam_rotation.w());

                              // increase iteration for next step in the servo loop.
                              iteration++; 
                         }
                         else
                         {
                              // Before exiting the program, we free all the memory by killing the task. 
                              task.kill();
                              
                              // We also want to reset the initialization for the next call.
                              simulation_initialized = false;
                         }
                    }
                    else
                    {
                          if(!simulation_initialized)
                          {
                              ROS_INFO("Simulation not yet initialized.");
                          }
                          if(request_message != control_message )
                          {
                              ROS_INFO("Wrong request message, use: %s", control_message.c_str() );
                          }
                    }
               }       
          }
          catch(vpException e) 
          {
               ROS_INFO("Could not simulate image based visual servo control.");
          }     
     	program_lock = false;
		return true;
     }
	else
	{
		ROS_INFO("Visual servo calculation currently already executing and service is therefore locked.");
		return false;
	}
}         			          
          			            
          			          
          			          
/***************************************************************************************************
 *
 *
 **************************************************************************************************/
bool calculateVelocityVector(pepper_servo_package::request_servo_velocity_vector::Request &req, pepper_servo_package::request_servo_velocity_vector::Response &res)
{
	std::vector<double> velocity_vector(6);
	if(!program_lock)
	{
          ROS_INFO("Calculating velocity vector.");
		program_lock = true;
		if(initialized)
		{
			ROS_INFO("Executing Halcon script to acquire images and features.");
			program_results = my_program.Execute();
			ROS_INFO("Halcon script has been executed, results are available");
		}
		else
		{
			ROS_INFO("Halcon script not yet initialized. Not executing program in %s.", ros::this_node::getName().c_str());
		}

		std::vector<double> velocity_vector(6);
		res.servo_velocity_vector = velocity_vector;
		ROS_INFO("Velocity vector has been sent: %f %f %f %f %f %f", velocity_vector[0], velocity_vector[1], velocity_vector[2], velocity_vector[3], velocity_vector[4], velocity_vector[5]);

		program_lock = false;
		return true;
	}
	else
	{
		ROS_INFO("Could not calculate velocity vector. Visual servo calculation currently already executing and service is therefore locked.");
		return false;
	}
}



/***************************************************************************************************
 *
 *	Initializes the .hdev script by loading it into the halcon engine.<<<<<<<<	
 *
 *	The actual program is not executed yet, this is done when this node service is triggered.
 *
 **************************************************************************************************/
void initializeHalconScript()
{
	ROS_INFO("Initializing .hdev Program");

	hdevengine.SetHDevOperatorImpl(new WindowHandlingImplementation);
	hdevengine.SetProcedurePath(halcon_ext_proc_path.c_str());

	ROS_INFO("Program path (.hdev file) : %s", halcon_program_path.c_str());
	ROS_INFO("External procedures path  : %s", halcon_ext_proc_path.c_str());

	try
	{
		my_program.LoadProgram(halcon_program_path.c_str());
		initialized = true;
		ROS_INFO("Halcon program initialisation succesful.");
	}
	catch (HDevEngineException& hdev_exception)
	{
		ROS_INFO("Halcon program initialisation NOT succesful.");
		ROS_INFO("Error category: %d : %s", 	hdev_exception.Category(),hdev_exception.CategoryText());
		ROS_INFO("Error number: %d",		     hdev_exception.HalconErrNum());
		ROS_INFO("Procedure: %s",		     hdev_exception.ExecProcedureName());
		ROS_INFO("Line: %d : %s",		     hdev_exception.ProgLineNum(),hdev_exception.ProgLineName());
	}
}




/***************************************************************************************************
 *
 *	Initializes the ROS node.
 *
 *	The program path of the .hdev file that is to be executed for image acquisition is passed in 
 *	the launchfile (halcon_program_path). Similarly, if the script uses any external procedures, 
 *	a path (halcon_ext_proc_path) is also passed. The halcon script is automaticcaly initialized.
 *
 *	A service is created that can be called to return a 'velocity vector': the next step of 
 *	correction that the robot needs to perform to servo to the target. This vector is calculated
 *	by 1) taking an new image, 2) calculate the image features, 3) calculate the velocity vector
 * 	based on the image features. 
 *
 **************************************************************************************************/
int main(int argc, char **argv)
{
     // Initialize this rosnode with an empty name string. This allow the node's name
     // to be set in the launchfile so that multiple copies of this node with different
     // names can be launched. Although you would probably not run more than 1 servo node, 
     // it is good practice to initialize the ros node's name in the launch file. 
     ros::init(argc, argv, "");
     sleep(10);
     
     
     // The nodehandle is initilized with a tilde ("~") The tilde refers to the node handle's 
     // namespace. This could be any namespace, which is roughly equivalent to a node name. 
     // However, the tilde refers to the current node's namespace. Why is this useful? In a 
     // roslaunch file, you can pass parameters to the system. There are "global" parameters 
     // that exist in the global, or default, namespace. These fall directly inside the <launch> 
     // tag. However, you can also put parameters under a <node> tag, and these will be in the 
     // local, or private, namespace of that node.
    	ros::NodeHandle node_handle("~");
    	
    	// Parameters that are initialized at start of the ros node.
    	// TODO: these should be made specific to a function.
	program_lock = false;
	initialized  = false;

     // Currently only one Halcon script can be initialized in this node. 
     // However, more could be added if required, although then more halcon paths should be added.
     node_handle.getParam("halcon_program_path",  halcon_program_path);
    	node_handle.getParam("halcon_ext_proc_path", halcon_ext_proc_path);
	initializeHalconScript();

     // Service for providing the main output from this node: a velocity vector.
	velocity_vector_output_service = node_handle.advertiseService("request_servo_velocity_vector", simulateVelocityVectorCalculation);
	
	// A publisher for a set of markers to visualize relevant positions in RVIZ.
	goal_marker_publisher = node_handle.advertise<visualization_msgs::Marker>( "goal_markers", 1 );
		
	// Initialize frame transformation parameters for simulated camera.
     tf::TransformBroadcaster      tf_broadcaster;
     tf::Transform                 transform;
     simulated_camera_position  =  tf::Vector3(0.0, 0.0, 0.0) ;
     simulated_camera_rotation  =  tf::Quaternion(0, 0, 0) ;
     
     // The ROS node will in the following loop.	
     ros::Rate rate(10.0);
     while (node_handle.ok())
     {
          // Frame transformations need to be updated constantly, otherwise they will fade out of existence. 
          transform.setOrigin(simulated_camera_position);
          transform.setRotation(simulated_camera_rotation);
          tf_broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world_frame", "simulated_camera_frame"));
          
          // Do one spin of the rosnode, e.g. checking and executing callbacks.
          // (http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning)
          ros::spinOnce();
          rate.sleep();
     }
		
	//ros::spin();
	return 0;
}
