#ifndef PEPPER_SERVO_H
#define PEPPER_SERVO_H

#include "ros/ros.h"


#include <tf/transform_broadcaster.h>


#include "std_msgs/String.h"
#include "HalconCpp.h"
#include "HDevEngineCpp.h"
#include <pepper_servo_package/request_servo_velocity_vector.h>
#include "window_handling.h"
#include <vector> 
#include <visualization_msgs/MarkerArray.h>
#include <visualization_msgs/Marker.h>

#include <visp/vpFeatureBuilder.h>
#include <visp/vpServo.h>
#include <visp/vpSimulatorCamera.h>

using namespace HalconCpp;
using namespace HDevEngineCpp;




/*°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
              The global variables in this frame are used for the HDevEngine.     
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°*/
HDevEngine hdevengine;
HDevProgram my_program;
HDevProgramCall program_results;
HTuple result;
std::string halcon_program_path;
std::string halcon_ext_proc_path;
/*‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡*/








/*°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
              The global variables in this frame are in the servo simulation   
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°*/
bool initialized;
bool program_lock;
bool simulation_initialized;

// Here we define the desired and initial position of the camera as two homogeneous matrices
vpHomogeneousMatrix cdMo(0, 0, 0.75, 0, 0, 0);
vpHomogeneousMatrix cMo(0.15, -0.1, 2.0,vpMath::rad(250), vpMath::rad(-140), vpMath::rad(150));

vpPoint point[4];
vpServo task;
vpFeaturePoint p[4], pd[4] ;
int iteration;
              
// For the simulation we need to create two homogeneous transformations wMc and wMo, 
// respectively to define the position of the camera, and the position of the object in 
// the world frame.
vpHomogeneousMatrix wMc, wMo;
              
// We create an instance of our free flying camera. 
vpSimulatorCamera robot;


tf::Vector3    simulated_camera_position;
tf::Quaternion simulated_camera_rotation;
          
          
/*‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡*/







/*°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
                          Global publishers and Subscribers of the ROS node   
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°*/
ros::Publisher           goal_marker_publisher;
ros::ServiceServer       velocity_vector_output_service;
/*‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡*/







/*°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
                              All functions within this ros node.
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°*/
void initializeHalconScript();
void display_trajectory(const vpImage<unsigned char> &I, std::vector<vpPoint> &point, const vpHomogeneousMatrix &cMo, const vpCameraParameters &cam);
bool simulateVelocityVectorCalculation(pepper_servo_package::request_servo_velocity_vector::Request  &req, pepper_servo_package::request_servo_velocity_vector::Response &res);
bool calculateVelocityVector(pepper_servo_package::request_servo_velocity_vector::Request  &req, pepper_servo_package::request_servo_velocity_vector::Response &res);
int main(int argc, char **argv);
/*‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡‡*/


#endif
