#include "hdev_engine.h"



                         /*
                        ###
                       ## ##
                      ##  ##
                       ####
                         :
                        #####
                       ######
                       ##  ##
                       ##  ##
                       ##  ##
                       ##  ##########
                       ##  #############
                  #######  ###############
              #############################
        .###################################
       #####################################;
       ##                                 ##.
       ##                                 ##
       #####################################
       ##                                 ##
       ##       The cake is a lie         ##
       ##                                 ###
    #####                                 #####
   ### ##################################### ###
  ###  ##                                 ##  ###
  ##   ## ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, ##   ##
   ##  #####################################  ##
    ##                                       ##
     ####                                 ####
       ######                         ######
          ##############################*/



/***************************************************
 *
 *	When this ros node is triggered on its trigger
 *	topic, the loaded halcon script is executed
 *	once.
 *
 *	The results of the script is saved in a global
 *	variable and can be accessed using the
 *	'request_output' service.
 *
 ***************************************************/
void triggerCallback(const std_msgs::String::ConstPtr& msg)
{
	ROS_INFO("Received trigger for %s.", ros::this_node::getName().c_str());

	if(initialized)
	{
		if(!program_lock)
		{
			ROS_INFO("Executing program in %s.", ros::this_node::getName().c_str());
			program_lock = true;

			program_results = my_program.Execute();

			ROS_INFO("Program has executed, results are available");
			program_lock = false;
		}
		else
		{
			ROS_INFO("Program currently executing and therefore locked. Not executing new program in %s.", ros::this_node::getName().c_str());
		}
	}
	else
	{
		ROS_INFO("Program not yet initialized. Not executing program in %s.", ros::this_node::getName().c_str());
	}
}


/***************************************************
 *
 *	Initializes the .hdev script by loading it
 *	into the halcon engine.
 *
 *	The program is not executed yet, this is only
 *	done when this node is triggered on its trigger
 *	topic.
 *
 ***************************************************/
void initializeHalconScript()
{
	ROS_INFO("Initializing .hdev Program");

	hdevengine.SetHDevOperatorImpl(new WindowHandlingImplementation);
	hdevengine.SetProcedurePath(ext_proc_path.c_str());

	ROS_INFO(".hdev program path: %s", program_path.c_str());
	ROS_INFO("External procedures path: %s", ext_proc_path.c_str());

	try
	{
		my_program.LoadProgram(program_path.c_str());
		initialized = true;
		ROS_INFO("Initialisation succesful.");
	}
	catch (HDevEngineException& hdev_exception)
	{
		ROS_INFO("Error category: %d : %s", 	hdev_exception.Category(),hdev_exception.CategoryText());
		ROS_INFO("Error number: %d",			hdev_exception.HalconErrNum());
		ROS_INFO("Procedure: %s",				hdev_exception.ExecProcedureName());
		ROS_INFO("Line: %d : %s",				hdev_exception.ProgLineNum(),hdev_exception.ProgLineName());
	}
}


/***************************************************
 *
 *	ROS service callback function for requesting
 *	output of the ran halcon script.
 *
 *  The request message is on topic 'request_output'
 *  and requires a 'request_tuple' service message
 *  format as input.
 *
 *  This service message request field is a String
 *  that corresonds to the variable/tuple name
 *  calculated in the Halcon script.
 *
 *  For example, if you want to request the value
 *  of 'cake_size' from the command line, then use
 *  the command (remove spaces and enters):
 *
 *   $ rosservice call /halcon_node_1/request_output
 *   	'{
 *   		tuple_name: "cake"
 *   	}'
 *
 *  Note that before this service can be called,
 *  the Halcon script must be run first by triggering
 *  this node on its trigger topic.
 *
 ***************************************************/
bool requestOutput(halcon::request_tuple::Request &req, halcon::request_tuple::Response &res)
{
	try
	{
		HTuple names = my_program.GetCtrlVarNames();

		HString out = names.ToString();

		std::string out_2 = out.Text();

		ROS_INFO("VarNames: %s", out_2.c_str() );

		HTuple result = program_results.GetCtrlVarTuple(req.tuple_name.c_str());
		double value = result[0].D();

		ROS_INFO("Requested output of variable '%s' with value '%f' has been sent.", req.tuple_name.c_str(), value);

		res.value = value;
		return true;
	}
	catch (HDevEngineException& hdev_exception)
	{
		ROS_INFO("Requested output of variable '%s' does not exist.", req.tuple_name.c_str());
		return false;
	}
}


/**************************************************
 *
 *	Initializes the ROS node.
 *
 *	The program path of the .hdev file that is to
 *	be executed is passed in the launchfile.
 *	Similarly, if the script uses any external
 *	procedures, this path (ext_proc_path)
 *	is also passed.
 *
 *	The halcon script is automaticcaly initialized.
 *
 *	The node creates a subscriber that listens to
 *	a trigger topic. When this trigger topic is
 *	called, the halcon script locks and is executed
 *	once.
 *
 *	The results are saved in a global variable and
 *	are accessible through the output_service
 *	(request_output). Please see the requestOutput
 *	function above for more information.
 *
 ***************************************************/
int main(int argc, char **argv)
{
	ros::init(argc, argv, "");
    ros::NodeHandle nh("~");

    nh.getParam("program_path",  program_path);
    nh.getParam("ext_proc_path", ext_proc_path);

	program_lock = false;
	initialized  = false;

	initializeHalconScript();

	std::string 	   trigger_topic 	= 	std::string("trigger");
	ros::Subscriber    trigger_sub 	   	= 	nh.subscribe(trigger_topic, 1000, triggerCallback);

	ros::ServiceServer output_service  	= 	nh.advertiseService("request_output", requestOutput);

	ros::spin();
	return 0;
}
