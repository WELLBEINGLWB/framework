/*
* Software License Agreement (BSD License)
*
* Copyright (c) 2014,UmeÃ¥ University
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following
* disclaimer in the documentation and/or other materials provided
* with the distribution.
* * Neither the name of Open Source Robotics Foundation nor
* the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior
* written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * StateMachine.cpp
 *
 *  Created on: Mar 1, 2012
 *      Author: Peter Hohnloser
 */

#include "crops_state_machine/StateMachine.h"

StateMachine::StateMachine(string outcomes[], int outcomeSize) :
    diag_pub_("update", diagnostic_, diagnostic_updater::FrequencyStatusParam(&min_freq_, &max_freq_, 0.1, 5),
              diagnostic_updater::TimeStampStatusParam())
{
  out_ = outcomes;
  outSize_ = outcomeSize;
  init();
  frequency_ = 100; // run in 100 Hz
  min_freq_ = frequency_ - frequency_ * 0.2;
  max_freq_ = frequency_ + frequency_ * 0.2;
  diagnostic_.setHardwareID("none");
}

void StateMachine::add(string label, State *state)
{
  state->setStateName(label);
  states_[label] = state;
}

string StateMachine::execute()
{
  string last_state_, trans_;
  crops_msgs::State state_msg;
  int i = 0;
  bool hasFinishd_ = false;
  checkTransitions();
  ros::Rate loop_rate(100);
  current_state_ = states_[start_state_];
  double start_time = ros::Time::now().toSec();
  while (ros::ok())
  {

    if (!current_state_->getPause())
    {
      state_msg.description = state_description_[current_state_->getStateName()];
      state_msg.name = current_state_->getStateName();
      state_msg.header.stamp = ros::Time::now();
      ROS_DEBUG("Current State: %s", state_msg.name.c_str());
      curr_state_pub_.publish(state_msg);
      last_state_ = current_state_->getStateName();
      trans_ = current_state_->execute(&state_data_);

      if (transitions_[last_state_].find(trans_) == transitions_[last_state_].end())
      {
        ROS_ERROR("#GUI State %s has no outcome %s ", last_state_.c_str(), trans_.c_str());
        run_ = false;
        rosspin_.join();
        exit(-1);
      }

      next_state_ = transitions_[last_state_][trans_];
      for (i = 0; i < outSize_; i++)
      {
        if (next_state_.compare(out_[i]) == 0)
        {
          hasFinishd_ = true;
          break;
        }
      }
      if (hasFinishd_)
      {
        break;
      }
      next.unlock();
      loop_rate.sleep();
      next.lock();
      if (current_state_->getStateName().compare(next_state_) != 0)
      {
        ROS_INFO("#SUM %s Duration %f sec", current_state_->getStateName().c_str(),
                 ros::Time::now().toSec() - start_time);
        start_time = ros::Time::now().toSec();
      }
      current_state_ = states_[next_state_];
    }
    else
    {
      loop_rate.sleep();
    }
  }
  state_msg.description = "State machine has finished";
  state_msg.name = "Exit";
  curr_state_pub_.publish(state_msg);
  run_ = false;
  rosspin_.join();
  ROS_DEBUG("State Machine exit");
  return out_[i];
}

void StateMachine::addTransitionFile(string file_name)
{
  TransitionParser tran;
  transitions_ = tran.parser(file_name, &state_description_, &start_state_);
}

/**
 *---------------------------------------------------------------Private methods--------------------------------------------------------------------
 */

void StateMachine::checkTransitions()
{
  map<string, map<string, string> >::iterator it;
  map<string, string>::iterator it2;
  int i;
  bool hasFailure_ = true;
  if (states_.find(start_state_) == states_.end())
  {
    ROS_ERROR("#GUI State machine has no start state %s", start_state_.c_str());
    ros::shutdown();
  }

  for (it = transitions_.begin(); it != transitions_.end(); it++)
  {
    map<string, string> &temp = it->second;
    for (it2 = temp.begin(); it2 != temp.end(); it2++)
    {

      if (states_.find(it2->second) == states_.end())
      {
        ROS_DEBUG("State Machine: state label [%s] outcome [%s] to [%s]", it->first.c_str(), it2->first.c_str(),
                  it2->second.c_str());
        for (i = 0; i < outSize_; i++)
        {
          if (out_[i].compare(it2->second) == 0)
          {
            hasFailure_ = false;
            break;
          }
        }
        if (hasFailure_)
        {
          ROS_ERROR("#GUI State ( %s )  outcome ( %s ) has no transition to next State ( %s )", it->first.c_str(),
                    it2->first.c_str(), it2->second.c_str());
          ros::shutdown();
        }
        hasFailure_ = true;
      }
    }
  }
}

void StateMachine::init()
{
  char *argv[1];
  int argc = 1;
  argv[0] = get_current_dir_name();
  run_ = true;
  ros::init(argc, argv, "StateMachine");
  curr_state_pub_ = n_.advertise<crops_msgs::State>("current_state", 1);
  rosspin_ = thread(&StateMachine::rosSpin, this);
  ROS_DEBUG("State Machine initialized");
}

void StateMachine::rosSpin()
{
  ROS_DEBUG("State Machine I'm alive message started");
  ros::ServiceServer service_ = n_.advertiseService("pause_request", &StateMachine::pause, this);
  ros::Subscriber sub_ = n_.subscribe("change_state", 1, &StateMachine::changeState, this);
  ros::Publisher alive_pub_ = n_.advertise<std_msgs::String>("update", 1);
  ros::Rate loop_rate(100);
  std_msgs::String msg;
  msg.data = "I'm alive";
  while (run_)
  {
    ros::spinOnce();
    alive_pub_.publish(msg);
    ros::Time timestamp = ros::Time::now();
    diag_pub_.tick(timestamp);
    diagnostic_.update();
    loop_rate.sleep();
  }
}

bool StateMachine::pause(crops_msgs::PauseRequest::Request &rep, crops_msgs::PauseRequest::Response &res)
{
  ROS_DEBUG("State Machine pause requested");
  res.succeded = true;

  if (current_state_->setPause(rep.pause))
  {
    res.succeded = false;
  }

  if (rep.pause)
  {
    // start pause timer
    pause_start_time_ = ros::Time::now().toSec();
  }
  else
  {
    // end pause timer and log duration to file
    ROS_INFO("#SUM Pause duration %f sec, (state: %s)", ros::Time::now().toSec() - pause_start_time_,
             current_state_->getStateName().c_str());
  }
  return true;
}

void StateMachine::changeState(const crops_msgs::changeState::ConstPtr& msg)
{
  ROS_DEBUG("State Machine change state to %s", msg->state_label.c_str());
  map<string, State*>::iterator it;
  current_state_->stop();
  for (it = states_.begin(); it != states_.end(); it++)
  {
    it->second->stop();
  }
  current_state_->setPause(false);
  next.lock();
  next_state_ = msg->state_label;
  next.unlock();

}
