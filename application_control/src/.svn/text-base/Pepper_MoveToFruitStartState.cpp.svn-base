/*
* Software License Agreement (BSD License)
*
* (C) 2014 Wageningen University & Research Centre, Wageningen UR Greenhouse Horticulture http://www.wageningenur.nl/greenhousehorticulture 
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following
* disclaimer in the documentation and/or other materials provided
* with the distribution.
* * Neither the name of Open Source Robotics Foundation nor
* the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior
* written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*/

#include "Pepper_MoveToFruitStartState.h"
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"

using std::string;
using std::map;

Pepper_MoveToFruitStartState::Pepper_MoveToFruitStartState() :
    SimpleActionState("/p2pAction") // name of the actionlib server node
{
  PubManipulatorState = n.advertise<crops_msgs::manipulatorState>("setManipulatorMode", 1000);
  //check if xpc_simulator or xpcTarget Hardware should be used
  ros::param::get("/crops_manipulator_udp/xpc_target", xpc_target_);
  manipulator_state_pub_ = n.advertise<crops_msgs::manipulatorState>("setManipulatorMode", 1);
  nh_.getParam("tcp_position", tcp_pos_);
  ros::param::get("/gripperType", gripperType);
  updateTCPsettings_ = nh_.advertise<crops_msgs::tcpInfo>("tcp_info", 1);
  first_ = true;
  no_fruit_cut = false;
  grasping_retry_number = 0;

  // TEST without collision, This will only work for the first fruit!!
  //collisionChecked = false;
  collisionChecked = true;

  end_effector_control = n.advertise<crops_msgs::end_effector_command>("end_effector_control", 1000);
  end_effector_feedback = n.subscribe("end_effector_status", 1, &Pepper_MoveToFruitStartState::ProcessEndEffectorStatus,
                                      this);

  // init to a default
  end_effector_status.fruit_not_removed = NULL;
  end_effector_status.gripping_failed = NULL;
  end_effector_status.fruit_removed = NULL;
  end_effector_status.cutter_ready = NULL;
  end_effector_status.gripping_successful = NULL;
  end_effector_status.gripper_ready = NULL;

  // init to a default at beginning of this state
  if (gripperType == "festo")
  {
    end_effector_command.endeffectortype = (int8_t)1; // Festo SP 2
    end_effector_command.gripper_status = true; // close gripper
    end_effector_command.cutter_status = false; // open cutter
    end_effector_command.led_status = false; // lights off
    end_effector_command.camera_status = true; // camera on;
    end_effector_command.nozzle_status = false; // no nozzle for pepper
    end_effector_command.fan_speed = 0;
  }
  else if (gripperType == "jaws")
  {
    end_effector_command.endeffectortype = (int8_t)1; // Festo SP 2
    end_effector_command.gripper_status = false; // turn on suction
    end_effector_command.cutter_status = false; // open ring
    end_effector_command.led_status = false; // lights off
    end_effector_command.camera_status = true; // camera on;
    end_effector_command.nozzle_status = false; // no nozzle for pepper
    end_effector_command.fan_speed = 0;
  }
  else
  {
    ROS_ERROR("Specified gripper type not exisitng!");
    sleep(30);
  }

  end_effector_control.publish(end_effector_command);

}

Pepper_MoveToFruitStartState::~Pepper_MoveToFruitStartState()
{

}

// end effector callback function
void Pepper_MoveToFruitStartState::ProcessEndEffectorStatus(const crops_msgs::EndEffectorStatus::ConstPtr& msg)
{
  end_effector_status.fruit_not_removed = msg->fruit_not_removed;
  end_effector_status.gripping_failed = msg->gripping_failed;
  end_effector_status.fruit_removed = msg->fruit_removed;
  end_effector_status.cutter_ready = msg->cutter_ready;
  end_effector_status.gripping_successful = msg->gripping_successful;
  end_effector_status.gripper_ready = msg->gripper_ready;
}
/**
 * Feedback from the arm
 */
void Pepper_MoveToFruitStartState::feedbackCb(const crops_msgs::p2pFeedbackConstPtr feedback)
{
  ROS_INFO("#GUI Progress: %.0f %%", feedback->progress * 100);
}

/**
 * Load fruit coordinates from the state machine and move the arm towards it
 */
string Pepper_MoveToFruitStartState::execute(map<string, boost::any> * data)
{
  string state_transition;
  data_ = data;
  // Get current goal pose
  goal_ = boost::any_cast<crops_msgs::p2pGoal>((*data)["arm_goal"]);



  // Get initial parten state before PepperMoveToVisualServoStartState,
  // either PepperMoveToFruit or PepperSelectFruitState.
  // The detect collision state can also precede this state, but that is
  // tracked by the parameter collision_parent_state
  initial_parent_state = boost::any_cast<std::string>((*data)["parent_state"]);

  if (n.hasParam("/disable_cut"))
  {
    ros::param::get("/disable_cut", no_fruit_cut);
  }
  else
  {
    ROS_WARN("rosparam /disable_cut is not set");
  }

  // Move TCP position forward to start 10 cm in front of the fruit wrt the TCP.
  crops_msgs::tcpInfo msg;
  msg.tcp_tooltype = 0;
  msg.tcp_transform.translation.x = (double)tcp_pos_[0];
  msg.tcp_transform.translation.y = (double)tcp_pos_[1];
  if (gripperType == "festo")
  {
    msg.tcp_transform.translation.z = (double)tcp_pos_[2] + (double)0.10; // 10 cm for Festo gripper
  }
  else
  {
    msg.tcp_transform.translation.z = (double)tcp_pos_[2] + (double)0.10; // only 10 cm for jaws gripper
  }
  msg.tcp_transform.rotation.x = tcp_pos_[3];
  msg.tcp_transform.rotation.y = tcp_pos_[4];
  msg.tcp_transform.rotation.z = tcp_pos_[5];
  msg.tcp_transform.rotation.w = tcp_pos_[6];
  updateTCPsettings_.publish(msg);

  // When not yet checked on a collision, determine goal and perform collision detection.
  /*if( !collisionChecked && (initial_parent_state == "PepperMoveToFruit") )
   {
   // Let collision state know which state calls him.
   ROS_INFO("#GUI Trying to check collision");
   std::string state_name 	= "PepperMoveToFruitStart";
   (*data)["collision_parent_state"] = state_name;

   ROS_INFO("Tool Center Point pose updated to move to fruit start pose.");
   sleep(0.1);

   collisionChecked	= true;
   state_transition 	= "CheckCollision";
   return state_transition;
   }
   // When checked on a collision, move the arm.
   else
   {
   return moveArm();
   }*/

  return moveArm(data);
}

/**
 * Moves arm to goal and checks on feedback.
 */
std::string Pepper_MoveToFruitStartState::moveArm(map<string, boost::any> * data)
{

  string outcome;
  if (first_)
  {

    if (n.hasParam("/robot_speed"))
    {
      ros::param::get("/robot_speed", robot_speed);
      //ROS_INFO("robot_speed=%i", robot_speed);
      if (robot_speed == 0)
        robot_speed = 1;
    }
    else
    {
      ROS_WARN("rosparam /robot_speed is not set");
      robot_speed = 100;
    }
    robot_speed_factor = 100.0 / (float)robot_speed;
    ROS_INFO("=== robot_speed=%d, robot_speed_factor=%.2f", robot_speed, robot_speed_factor);
    ROS_INFO("=== robot desired time=%.2f", 1.5 * robot_speed_factor);
    goal_.desired_time = 1.5 * robot_speed_factor; // in seconds
    //goal_.desired_time = 1.5;
    goal_.use_hardware = xpc_target_;



   /*ROS_INFO("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
   geometry_msgs::PoseStamped fruit_poses[] = boost::any_cast<geometry_msgs::PoseStamped>((*data)["fruit_poses"]);
   for(int k=0 ; k<9 ; k++){
  	  ROS_INFO(
      		"Received move to fruit state fruit pose %i before transformation: (%.2f, %.2f, %.2f %2f)", k,
      		fruit_poses[k].pose.orientation.x, fruit_poses[k].pose.orientation.y, fruit_poses[k].pose.orientation.z,
      		fruit_poses[k].pose.orientation.w);
   ROS_INFO("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"); 

   int grasping_retry_number = boost::any_cast<int>((*data)["grasping_retry_number"]);
   ROS_INFO("Grasping retry number %i", grasping_retry_number ); 
  }
  */



  ROS_INFO("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");

  if(grasping_retry_number == 0)
  { 
     	ROS_INFO("Grasping retry number not yet set, first try"); 
  }
  else
  {
  	grasping_retry_number = boost::any_cast<int>((*data)["grasping_retry_number"]);
  	ROS_INFO("Recieved grasping retry number from MoveToFruitState %i", grasping_retry_number);  
  }
  ROS_INFO("Grasping number %i", grasping_retry_number ); 

  std::string name = "fruit_pose_";
  name += boost::to_string(grasping_retry_number);
  geometry_msgs::PoseStamped fruit_pose = boost::any_cast<geometry_msgs::PoseStamped>((*data)[name]);

// testing Jochen 60 degress fixed approach
//  fruit_pose.pose.orientation.x = 0;
//  fruit_pose.pose.orientation.y = 0;
//  fruit_pose.pose.orientation.z = -0.50;
//  fruit_pose.pose.orientation.w = 0.87;
// testing end


  ROS_INFO("Received move to fruit state fruit pose %i in frame %s with pose: (%.2f, %.2f, %.2f %2f)", 
	   grasping_retry_number,
	   fruit_pose.header.frame_id.c_str(),
      	   fruit_pose.pose.orientation.x, 
	   fruit_pose.pose.orientation.y,
	   fruit_pose.pose.orientation.z,
      	   fruit_pose.pose.orientation.w);
 

  goal_.goal_pose.orientation.x = fruit_pose.pose.orientation.x ;
  goal_.goal_pose.orientation.y = fruit_pose.pose.orientation.y ;
  goal_.goal_pose.orientation.z = fruit_pose.pose.orientation.z ;
  goal_.goal_pose.orientation.w = fruit_pose.pose.orientation.w ;

  (*data)["arm_goal"] = goal_;

  if(grasping_retry_number == 0)
  { 
     	grasping_retry_number = 1;
  }

  sleep(1);
  ROS_INFO("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"); 

 

    ROS_INFO("#GUI moveToFruitState moves to position (%.2f %.2f %.2f) ", goal_.goal_pose.position.x,
             goal_.goal_pose.position.y, goal_.goal_pose.position.z);
    ROS_INFO("#GUI moveToFruitState moves to orientation (%.2f %.2f %.2f %2f) ", goal_.goal_pose.orientation.x,
             goal_.goal_pose.orientation.y, goal_.goal_pose.orientation.z, goal_.goal_pose.orientation.w);

    setFeedbackCallback(boost::bind(&Pepper_MoveToFruitStartState::feedbackCb, this, _1));
    //sleep(3);
    sendGoal();
    first_ = false;
  }

  actionlib::SimpleClientGoalState current_state_ = ac_.getState();

  switch (current_state_.state_)
  {
    /*
     * The action client (the arm) can be in different states. It's possible to define
     * what the action server (movetoFruitState) should do in each of these situations:
     case actionlib::SimpleClientGoalState::PREEMPTED:
     case actionlib::SimpleClientGoalState::RECALLED:
     case actionlib::SimpleClientGoalState::REJECTED:
     case actionlib::SimpleClientGoalState::PENDING:
     case actionlib::SimpleClientGoalState::ACTIVE:
     case actionlib::SimpleClientGoalState::LOST:
     */
    case actionlib::SimpleClientGoalState::SUCCEEDED:
      first_ = true;
      if (ac_.getResult()->reached_goal)
      {
        ROS_INFO("#GUI Arm has reached move to fruit starting position.");
        (*data_)["found_fruit"] = true;
        // Set TCP position in original position after movement
        crops_msgs::tcpInfo msg;
        msg.tcp_tooltype = 0;
        msg.tcp_tooltype = 0;
        msg.tcp_transform.translation.x = tcp_pos_[0];
        msg.tcp_transform.translation.y = tcp_pos_[1];
        msg.tcp_transform.translation.z = tcp_pos_[2];  // when substracting a value, the gripper will move more into the fruit
        msg.tcp_transform.rotation.x = tcp_pos_[3];
        msg.tcp_transform.rotation.y = tcp_pos_[4];
        msg.tcp_transform.rotation.z = tcp_pos_[5];
        msg.tcp_transform.rotation.w = tcp_pos_[6];
        updateTCPsettings_.publish(msg);
        ROS_INFO("Tool Center Point pose updated to original pose.");

        if (initial_parent_state == "PepperMoveToVisualServoStart" || initial_parent_state == "PepperMoveToFruitRetry")
        {
          outcome = "PepperMoveToFruit";

        }
        else
        {

      	if (initial_parent_state == "PepperMoveToFruit")
      	{
        	// we have sucessfull gripped a fruit
      		//		Festo gripper=it is already cut, we don't need to do anything
      		//		Jaws gripper=it is not cut yet, we need to do now
			if (gripperType=="jaws"){
				ROS_INFO("WUR Gripper, vac. is still on, will try to cut now..");
				// TODO check if fruit is still fixed
				if (end_effector_status.gripping_successful) {
					ROS_WARN("==> Yes, fruit is still attached to the suction cup :-)");
					end_effector_command.gripper_status  = true; 		// leave vac on
					if (no_fruit_cut) end_effector_command.cutter_status   = false;
					else end_effector_command.cutter_status   = true;		// close cutter
					end_effector_control.publish(end_effector_command);
					sleep(1); // wait to close cutter
					// TODO check succesfull cut
					if (no_fruit_cut) end_effector_command.gripper_status  = false; // turn vac off
					else end_effector_command.gripper_status  = true; 		// turn vac not off = only at bin position
					end_effector_command.cutter_status   = false;		// open cutter
					end_effector_control.publish(end_effector_command);
				}
				else {
					ROS_WARN("==> Oh no, fruit lost from the suction cup :-(");
					ROS_INFO("To be implementd: give it a retry...");
					end_effector_command.gripper_status  = false; 		// turn vac off
					end_effector_command.cutter_status   = false;		// open cutter
					end_effector_control.publish(end_effector_command);
				}
			}else{
			if (gripperType=="festo"){
				if (end_effector_status.gripping_successful) {
					if (no_fruit_cut) end_effector_command.cutter_status   = false;
					else end_effector_command.cutter_status   = true;		// close cutter
					end_effector_control.publish(end_effector_command);
					sleep(1); // wait to close cutter
					// TODO check succesfull cut
					//end_effector_command.cutter_status   = false;		// open cutter
					//end_effector_control.publish(end_effector_command);
				}
				else {
					ROS_WARN("==> Oh no, fruit lost :-(");
					ROS_INFO("To be implementd: give it a retry...");
					end_effector_command.gripper_status  = false; 		// turn vac off
					end_effector_command.cutter_status   = false;		// open cutter
					end_effector_control.publish(end_effector_command);
				}

							
			}}

      		outcome = "PepperMoveToBasket";

          }
          else
          {
            ROS_WARN("#GUI Initial parent state not set properly.");
          }
        }
      }
      else
      {
        ROS_WARN("#GUI Not succeeded - motion not possible!!, ->reached_goal==false");
        (*data_)["found_fruit"] = false;
        outcome = "Out of reach";
      }
      first_ = true;
      //collisionChecked 	= false;
      break;

    case actionlib::SimpleClientGoalState::PREEMPTED:
      ROS_INFO("#GUI Arm could not reach the fruit");
      (*data_)["found_fruit"] = false;
      first_ = true;
      //collisionChecked 	= false;
      outcome = "Out of reach";
      break;

    default:
      outcome = "Moving";
      break;
  }
  // TODO testing only: set collisionChecked=true always to prevent collision check
  collisionChecked = true;
  return outcome;
}

