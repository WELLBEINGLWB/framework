/*
* Software License Agreement (BSD License)
*
* Copyright (c) 2014,Ume√• University
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following
* disclaimer in the documentation and/or other materials provided
* with the distribution.
* * Neither the name of Open Source Robotics Foundation nor
* the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior
* written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*/

#include "selectFruitState.h"
#include <tf_rot.hpp>
using std::string;
using std::map;
using std::vector;

/**
 * Constructor
 */
SelectFruitState::SelectFruitState()
{
  fruit_number_ = 0;
  pose_number_ = 0;
  first_ = true;
  one_pose_ = true;
  fruit_found_ = false;
  if (!nh_.getParam("crops_main/frame_id", camera_frame_))
  {
    ROS_ERROR("#GUI SelectFruitState could not load the crops_main/frame_id");
  }
  if (!nh_.getParam("crops_main/one_pose", one_pose_))
  {
    ROS_WARN("#GUI SelectFruitState could not load the crops/one_pose");
  }
  if (one_pose_)
  {
    ROS_INFO("#GUI SelectFruitState uses one pose");
  }
  else
  {
    ROS_INFO("#GUI SelectFruitState uses several poses");
  }
}

SelectFruitState::~SelectFruitState()
{
}

/**
 * Make a service request to the fruit localization node to get a list of fruits.
 */
string SelectFruitState::execute(map<string, boost::any> * data)
{

  // Get a list with fruit coordinates from the state machine
  crops_msgs::Multiple_Affordances fruit_list = boost::any_cast<crops_msgs::Multiple_Affordances>((*data)["fruit"]);

  // uses One or several poses for a fruit
  ROS_INFO("Execute");
  if (!first_)
  {
    fruit_found_ = boost::any_cast<bool>((*data)["found_fruit"]);
    if (!fruit_found_)
    {
      int number_of_poses = fruit_list.Multiple_Fruits[fruit_number_].poses.size();
      if (pose_number_ < number_of_poses - 1 && !one_pose_)
      {
        pose_number_++;
        ROS_INFO("#GUI Selecting next pose for fruit number %d", fruit_number_ +1);
      }
      else
      {
        fruit_number_++;
        pose_number_ = 0;
        stat_msg_.fruit_missed = true;
        stat_msg_.start_fruit_clock = "stop";
        stat_pub_.publish(stat_msg_);
        ROS_WARN("#GUI Fruit missed");
      }
    }
    else
    {
      fruit_number_++;
      pose_number_ = 0;
    }
  }
  first_ = false;
  int n_fruits = fruit_list.NumberOfFruits;
  ROS_INFO("fruit_number: %d, nFruits: %d",fruit_number_,n_fruits);
  if (fruit_number_ >= n_fruits)
  {
    // All fruits in the list has been selected (and hopefully picked) already
    // For some reason we need two ros_info. Otherwise nothing is printed before return :(
    ROS_INFO("#GUI All fruits picked");
    ROS_INFO("Have a nice day! :-)");

    // Reset the counter so we can call the state again with new fruit coordinates
    fruit_number_ = 0;
    pose_number_ = 0;
    stat_msg_.fruit_missed = false;
    first_ = true;

    // Stop the total clock in the GUI:
    stat_msg_.start_tot_clock = "stop";
    stat_pub_.publish(stat_msg_);

    return "All fruits picked";
  }
  ROS_INFO("Fruit Number: %d, Nfruits: %d,  PoseNo: %d", fruit_number_+1, n_fruits, pose_number_+1);
  // transform from camera(TOF) coordinate system to the global
  geometry_msgs::PoseStamped goal_pose, fruit_pose;
  fruit_pose.header.frame_id = camera_frame_; // camera to manipulator
//  fruit_pose.header.frame_id = "Elem_0"; // manipulator to camera
  fruit_pose.header.stamp = fruit_list.header.stamp;
  fruit_pose.pose = fruit_list.Multiple_Fruits[fruit_number_].poses[pose_number_];

  ROS_INFO(
      "Fruit pose before transformation: ((%.2f, %.2f, %.2f), (%.2f, %.2f, %.2f %2f))",
      fruit_pose.pose.position.x, fruit_pose.pose.position.y, fruit_pose.pose.position.z,
      fruit_pose.pose.orientation.x, fruit_pose.pose.orientation.y, fruit_pose.pose.orientation.z,
      fruit_pose.pose.orientation.w);

  double roll, pitch, yaw;
  tf::Quaternion q;
  q.setValue(fruit_pose.pose.orientation.x, fruit_pose.pose.orientation.y, fruit_pose.pose.orientation.z,
             fruit_pose.pose.orientation.w);
  tf::Matrix3x3 m(q);
  m.getRPY(roll, pitch, yaw);
  ROS_INFO("Before transformation  ROLL = %f; PITCH = %f; YAW = %f", roll, pitch, yaw);
  try
  {
    //  listener_.transformPose(camera_frame_, ros::Time::now(), fruit_pose, "Elem_0", goal_pose); // manipulator to camera
    listener_.transformPose("Elem_0", ros::Time::now(), fruit_pose, camera_frame_, goal_pose); // camera to manipulator
    ROS_INFO(
        "%s: (%.2f, %.2f. %.2f) -----> Elem_0: (%.2f, %.2f, %.2f) at time %.2f", camera_frame_.c_str(), fruit_pose.pose.position.x, fruit_pose.pose.position.y, fruit_pose.pose.position.z, goal_pose.pose.position.x, goal_pose.pose.position.y, goal_pose.pose.position.z, goal_pose.header.stamp.toSec());
  }
  catch (tf::TransformException& ex)
  {
    ROS_ERROR(
        "Received an exception trying to transform a point from %s\" to \"Elem_0\": %s", camera_frame_.c_str(), ex.what());
  }

  ROS_INFO(
          "Fruit pose after transformation: ((%.2f, %.2f, %.2f), (%.2f, %.2f, %.2f %2f))", goal_pose.pose.position.x, goal_pose.pose.position.y, goal_pose.pose.position.z, goal_pose.pose.orientation.x, goal_pose.pose.orientation.y, goal_pose.pose.orientation.z, goal_pose.pose.orientation.w);


  // set a fixed orientation for debugging so that we do not run into quaternion transform errors
  goal_pose.pose.orientation.x = 0;
  goal_pose.pose.orientation.y = 0;
  goal_pose.pose.orientation.z = -0.7068;
  goal_pose.pose.orientation.w = 0.7073;

//  quat[0] = goal_pose.pose.orientation.w;
//  quat[1] = goal_pose.pose.orientation.x;
//  quat[2] = goal_pose.pose.orientation.y;
//  quat[3] = goal_pose.pose.orientation.z;
//  quat2kardan(quat, ang, dcm);
//
//  ROS_INFO("After transformation  ROLL = %f; PITCH = %f; YAW = %f", ang[0], ang[1], ang[2]);

  //q.setValue(goal_pose.pose.orientation.x, goal_pose.pose.orientation.y, goal_pose.pose.orientation.z,
   //          goal_pose.pose.orientation.w);
  //m.setRotation(q);
  //m.getRPY(roll, pitch, yaw);
  //ROS_INFO("After transformation  ROLL = %f; PITCH = %f; YAW = %f", roll, pitch, yaw);

  crops_msgs::p2pGoal goal;
  goal.goal_pose = goal_pose.pose;
  (*data)["arm_goal"] = goal;

  ROS_INFO(
      "Fruit selected [Elem_0 frame]: ((%.2f, %.2f, %.2f), (%.2f, %.2f, %.2f %2f))", goal.goal_pose.position.x, goal.goal_pose.position.y, goal.goal_pose.position.z, goal_pose.pose.orientation.x, goal_pose.pose.orientation.y, goal_pose.pose.orientation.z, goal_pose.pose.orientation.w);

  return "Fruit selected";
}

