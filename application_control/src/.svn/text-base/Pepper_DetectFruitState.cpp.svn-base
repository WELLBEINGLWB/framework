/*
* Software License Agreement (BSD License)
*
* (C) 2014 Wageningen University & Research Centre, Wageningen UR Greenhouse Horticulture http://www.wageningenur.nl/greenhousehorticulture
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following
* disclaimer in the documentation and/or other materials provided
* with the distribution.
* * Neither the name of Open Source Robotics Foundation nor
* the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior
* written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*/

#include "Pepper_DetectFruitState.h"

/**
 * Constructor
 */
Pepper_DetectFruitState::Pepper_DetectFruitState() : SimpleActionState("/pepper_sensory_system_motor")
{
	fruit_clt_            = nh_.serviceClient<crops_msgs::Fruits_req>("fruit_request");
	reset_fruit_detection = nh_.advertise<std_msgs::String>("reset_fruit_detection", 1000);

	// Initialization of software request topic for SR camera. Topic name defined in launchfile.
	img_request_topic_sr_.clear();
	img_request_topic_avt_.clear();
	nh_.getParam("img_req_topic_sr",img_request_topic_sr_);
	nh_.getParam("img_req_topic_avt",img_request_topic_avt_);
	nh_.getParam("crops_main/use_pepper_sensor_rig", _use_pepper_sensor_rig);

	trigger_pub_sr_  = nh_.advertise<crops_msgs::ImageRequest>(img_request_topic_sr_,1);
	trigger_pub_avt_ = nh_.advertise<crops_msgs::ImageRequest>(img_request_topic_avt_,1);

	acq_status_sub_sr_= nh_.subscribe("sr_image_status",1,&Pepper_DetectFruitState::imageAcqSRStatusCallback,this);
	stem_detection = nh_.subscribe("crops_pepper_stem_detection",1,&Pepper_DetectFruitState::stemDetectionCallback,this);
}

Pepper_DetectFruitState::~Pepper_DetectFruitState()
{
}

/**
 * Make a service request to the fruit localization node to get a list of fruits.
 */
std::string Pepper_DetectFruitState::execute(std::map<std::string, boost::any> * data)
{

	// Clear fruit_message_ in state machine and in grasping and planning node.
	fruit_message_.NumberOfFruits = 0;
	fruit_message_.Multiple_Fruits.resize(0);
	std_msgs::String clear_message;
	clear_message.data = "clear";
	reset_fruit_detection.publish(clear_message);
	crops_msgs::pepperSensorySystemMotorAction goal;
	ROS_INFO("use_pepper_sensor_rig=%i",_use_pepper_sensor_rig);

	//goal.action_goal.goal.pepper_sensorrig_motor_control_message = "light_rig_unfold";
	//ac_.sendGoal(goal.action_goal.goal);
	//sleep(1);


	bool found_fruit = false;
	bool found_stems = false;
	//while(!found_fruit || !found_stems)
    	//while(!found_fruit)
	//{
		crops_msgs::ImageRequest img_req_msg;
    		
		if(!found_stems)
		{
			// Take stereo image
			//if (_use_pepper_sensor_rig) {
				ROS_INFO("Taking stereo image for stem detection.");
				ROS_INFO("Changing exposure dynamically.");
				// hotfix: left cam seems to be darker, use therefore longer time
				system("rosrun dynamic_reconfigure dynparam set /prosilica_gc2450_driver exposure 20");
				//usleep(10000);
				system("rosrun dynamic_reconfigure dynparam set /prosilica_gc2450_2_driver exposure 20");
				//usleep(10000);

				goal.action_goal.goal.pepper_sensorrig_motor_control_message = "lights_on";
				ac_.sendGoal(goal.action_goal.goal);
				sleep(1);
				ROS_INFO("Done changing exposure dynamically.");

				//goal.action_goal.goal.pepper_sensorrig_motor_control_message = "camera_stereo_image";
				//ac_.sendGoal(goal.action_goal.goal);
				//sleep(1);

				img_req_msg.header.stamp = ros::Time::now();
				img_req_msg.num_images = 1;
				img_req_msg.stereo = true;
				ROS_INFO("Request AVT stereo images for stem detection");
				trigger_pub_avt_.publish(img_req_msg);


				//if(detected_stems->main_stem != NULL)
				//if(true)
				//{
				//		ROS_INFO("Found some stems!");
				//		(*data)["detected_stems"] = detected_stems;
				//	found_stems = false;
				//}

				// next line for testing only
			//}
			
			found_stems = true;

	   }


		if(!found_fruit )
		{
			//if (_use_pepper_sensor_rig) {
			ROS_INFO("Changing exposure dynamically for fruit detection.");
			system("rosrun dynamic_reconfigure dynparam set /prosilica_gc2450_driver exposure 60");  // was 80 with light rig
			usleep(10000);
			system("rosrun dynamic_reconfigure dynparam set /prosilica_gc2450_2_driver exposure 60"); // was 80
			sleep(1);

			goal.action_goal.goal.pepper_sensorrig_motor_control_message = "lights_on";
			ac_.sendGoal(goal.action_goal.goal);
			sleep(1);

			//goal.action_goal.goal.pepper_sensorrig_motor_control_message = "camera_original_image";
			//ac_.sendGoal(goal.action_goal.goal);
			ROS_INFO("==@== Request AVT image for fruit detection.");
			img_req_msg.header.stamp = ros::Time::now();
			img_req_msg.num_images = 1;
			img_req_msg.stereo = false;
			trigger_pub_avt_.publish(img_req_msg);
			//}
			//else
			//{
			//	ROS_INFO("===No sensor rig, did not trigger cameras");
			//}


			ROS_INFO("Request SR image for fruit detection with lights off.");
			// turn lights off
			goal.action_goal.goal.pepper_sensorrig_motor_control_message = "lights_off";
			ac_.sendGoal(goal.action_goal.goal);
			usleep(10000);
			img_req_msg.header.stamp = ros::Time::now();
			img_req_msg.num_images = 1;
			img_req_msg.stereo = false;
			trigger_pub_sr_.publish(img_req_msg);

			ROS_INFO("Calling fruit request1 service.");
			crops_msgs::Fruits_req srv;

			int number_of_tries = 0;
			while(number_of_tries < 10 && !found_fruit)
			{
				ROS_INFO("Called fruit request service %i times", number_of_tries);
				if (fruit_clt_.call(srv))
				{
					fruit_message_ = srv.response.fruit_list;
					// Send the fruit message back to the state machine (so other states can use it):
					(*data)["fruit"] = fruit_message_;
					printFruits(); // Print out all fruit coordinates on screen
					stat_msg_.fruit_count = fruit_message_.NumberOfFruits;
					stat_pub_.publish(stat_msg_);

					if(fruit_message_.NumberOfFruits > 0)
					{
						found_fruit = true ;
						ROS_INFO("Found fruit.");
					}
					else
					{				
						ROS_INFO("No fruit found yet. Calling service again.");
					}
					number_of_tries++;
				}
				else
				{
					ROS_ERROR("Failed to call fruit request service.");
				}
				sleep(1);
			}
		}



	goal.action_goal.goal.pepper_sensorrig_motor_control_message = "lights_off";
	ac_.sendGoal(goal.action_goal.goal);
	//sleep(1);
	//goal.action_goal.goal.pepper_sensorrig_motor_control_message = "light_rig_fold";
	//ac_.sendGoal(goal.action_goal.goal);
	//sleep(1);

	return "Found fruit";
}


void Pepper_DetectFruitState::imageAcqSRStatusCallback(const crops_msgs::ImageAcqStatus::ConstPtr &msg){

	if(msg->status.compare("done")!=0)
	{
		ROS_INFO("Warning, SR image not properly taken- status %s ",msg->status.c_str());
	}

}

void Pepper_DetectFruitState::stemDetectionCallback(const crops_msgs::pepper_stems::ConstPtr &msg){

	ROS_INFO("Pepper Stem Detection has returned a result.");
	detected_stems = msg;
}





/**
 * Display the location of the fruits on screen
 */
void Pepper_DetectFruitState::printFruits()
{

	//ROS_INFO("@@@Print fruits", getStateName().c_str());
	ROS_INFO("%s reports:", getStateName().c_str());
	int fruit_count = fruit_message_.NumberOfFruits;
	double x[fruit_count], y[fruit_count], z[fruit_count];
	ROS_INFO("#GUI Number of fruits localized: %d", fruit_count);
        double age = ros::Time::now().toSec() - fruit_message_.header.stamp.toSec();
	ROS_INFO("Message age %.3f s:", age);

	for (int i = 0; i < fruit_count; i++)
	{
		//int size = fruit_message_.Multiple_Fruits[i].poses.size();
                //ROS_INFO("Fruit pose array size %i", size);
		//if(size>0)
		//{
			x[i] = fruit_message_.Multiple_Fruits[i].poses[0].position.x;
			y[i] = fruit_message_.Multiple_Fruits[i].poses[0].position.y;
			z[i] = fruit_message_.Multiple_Fruits[i].poses[0].position.z;
			ROS_INFO("Fruits at location: (%.2f %.2f %.2f)", x[i], y[i], z[i]);
		//	ROS_INFO("Fruit pose not empty");
		//}
		//else
		//{
		//	ROS_INFO("Skipping fruit position: empty poses");
		//}
	}


}

