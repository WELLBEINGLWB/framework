/*
* Software License Agreement (BSD License)
*
* Copyright (c) 2014,UmeÃ¥ University
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
* * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following
* disclaimer in the documentation and/or other materials provided
* with the distribution.
* * Neither the name of Open Source Robotics Foundation nor
* the names of its contributors may be used to endorse or promote
* products derived from this software without specific prior
* written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * TransitionPaser.cpp
 *
 *  Created on: Mar 22, 2012
 *      Author: Peter Hohnloser
 */

#include "crops_state_machine/TransitionParser.h"

void operator >>(const YAML::Node& node, state_transition& state_tran)
{
  node["state_label"] >> state_tran.state_label;
  node["descriptive_name"] >> state_tran.descriptive_name;
  const YAML::Node& trans = node["transitions"];
  for (YAML::Iterator it = trans.begin(); it != trans.end(); ++it)
  {
    transition t;
    it.first() >> t.outcome;
    it.second() >> t.next_state;
    state_tran.transitions.push_back(t);
  }
}

void operator >>(const YAML::Node& node, state_machine& sm)
{
  node["start_state"] >> sm.start_state;
  node["state"] >> sm.states;
}

map<string, map<string, string> > TransitionParser::parser(string file_name, map<string, string> * state_description,
                                                           string *start_state)
{
  string path(file_name.substr(0, file_name.size() - 4));
  path += "dot";
  ROS_INFO("transition file path: %s", file_name.c_str());
  ROS_INFO("dot file path: %s ", path.c_str());
  std::ofstream dotfile_(path.c_str());
  dotfile_ << "digraph{\n";

  map<std::string, map<std::string, std::string> > transitions_;
  try
  {
    std::ifstream fin(file_name.c_str());
    YAML::Parser parser(fin);
    YAML::Node doc;
    parser.GetNextDocument(doc);
    if (doc.size() < 1)
    {
      ROS_ERROR( "WRONG file or file does not exists %s", file_name.c_str());
      ros::shutdown();
    }
    doc[0]["start_state"] >> (*start_state);
    for (unsigned i = 1; i < doc.size(); i++)
    {
      state_transition states;
      doc[i]["state"] >> states;
      (*state_description)[states.state_label] = states.descriptive_name;
      for (unsigned d = 0; d < states.transitions.size(); d++)
      {
        ROS_DEBUG("State label: [%s] outcome [%s] to next State [%s]",states.state_label.c_str(),states.transitions[d].outcome.c_str(),states.transitions[d].next_state.c_str());
        transitions_[states.state_label][states.transitions[d].outcome] = states.transitions[d].next_state;
        dotfile_ << states.state_label << "->" << states.transitions[d].next_state << " [ label=" << '"'
            << states.transitions[d].outcome << '"' << " ];" << "\n";
      }
    }
  }
  catch (YAML::ParserException& e)
  {
    ROS_ERROR( "Error parsing the yaml-file. Do not use tabs, only spaces");
    ros::shutdown();
  }
  dotfile_ << "}\n";
  dotfile_.close();
  ROS_INFO("%s file created",path.c_str());
  string execute("dot -Tps ");
  execute += path;
  execute += " -o ";
  execute += path.substr(0, path.size() - 4);
  execute += ".pdf";
  if (0 != system(execute.c_str()))
  {
    ROS_ERROR("Couldn't create a pdf from %s.",path.c_str());
  }
  return transitions_;
}
